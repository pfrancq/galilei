/*

	GALILEI Research Project

	GProfileCalcFeedback.h

	Vector Computing Method  - Implementation.

	Copyright 2001-2002 by the Université Libre de Bruxelles.

	Authors:
		Pascal Francq (pfrancq@ulb.ac.be).

	Version $Revision$

	Last Modify: $Date$

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Library General Public
	License as published by the Free Software Foundation; either
	version 2.0 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Library General Public License for more details.

	You should have received a copy of the GNU Library General Public
	License along with this library, as a file COPYING.LIB; if not, write
	to the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
	Boston, MA  02111-1307  USA

*/



//-----------------------------------------------------------------------------
// include files for ANSI C/C++
#include <stdlib.h>
#include <math.h>


//-----------------------------------------------------------------------------
// include files for R Project
#include <rstd/rcursor.h>
using namespace R;


//-----------------------------------------------------------------------------
//include files for GALILEI
#include <gprofilecalcfeedback.h>
#include <docs/gdocvector.h>
#include <langs/gdict.h>
#include <langs/glang.h>
#include <profiles/gprofile.h>
#include <profiles/gprofdoc.h>
#include <profiles/gsubprofilevector.h>
#include <infos/giword.h>
#include <infos/giwordlist.h>
#include <infos/giwordweight.h>
#include <infos/giwordsweights.h>
#include <sessions/gsession.h>
using namespace GALILEI;



//-----------------------------------------------------------------------------
//
//  GProfileCalcFeedback
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
GProfileCalcFeedback::GProfileCalcFeedback(GFactoryProfileCalc* fac) throw(bad_alloc)
	: GProfileCalc(fac), MaxNonZero(60), RelFactor(1.0), FuzzyFactor(0.25),
	  IrrelFactor(0.75), Positive(false), isf(true), Vectors(5000),
	  NbDocsWords(5000), NbDocs(0), MaxOrderSize(5000)
{
	Order=new GIWordWeight*[MaxOrderSize];
}


//-----------------------------------------------------------------------------
void GProfileCalcFeedback::ApplyConfig(void)
{
	MaxNonZero=Factory->GetUInt("MaxSize");
	RelFactor=Factory->GetDouble("RelFactor");
	FuzzyFactor=Factory->GetDouble("FuzzyFactor");
	IrrelFactor=Factory->GetDouble("IrrelFactor");
	Positive=Factory->GetBool("Positive");
	isf=Factory->GetBool("isf");
}


//-----------------------------------------------------------------------------
void GProfileCalcFeedback::Connect(GSession* session)
{
	GProfileCalc::Connect(session);
}


//-----------------------------------------------------------------------------
void GProfileCalcFeedback::Disconnect(GSession* session)
{
	GProfileCalc::Disconnect(session);
}


//-----------------------------------------------------------------------------
void GProfileCalcFeedback::ComputeGlobal(GSubProfile* subprofile) throw(bad_alloc)
{
	GIWordWeightCursor Words;
	GProfDocCursor Docs;
	GDocVector* CurDoc;
	GIWordWeight* w;
	bool Add;
	tDocJudgement Fdbk;
	double MaxFreq;
	double Factor;
	double Freq;

	// Clear all containers before computing
	Vectors.Clear();
	NbDocsWords.Clear();
	NbDocs=0;

	// Go through all documents, to compute the number of documents "OK", "KO"
	// and "N" for each language and the number of documents for each index term.
	Docs=subprofile->GetProfDocCursor();
	for(Docs.Start();!Docs.End();Docs.Next())
	{
		// If the assessment of the document  is not relevant
		// -> don't treat for the profiles computing
		CurDoc=dynamic_cast<GDocVector*>(Docs()->GetDoc());
		Fdbk=Docs()->GetFdbk();
		if((IrrelFactor==0.0)&&(!(Fdbk & djOK))&&(!(Fdbk & djNav))&&(!(Fdbk & djKO))) continue;

		// Add total number of document judged for the current language
		NbDocs++;

		// Update number of documents where appear each index term.
		Words=CurDoc->GetWordWeightCursor();
		for(Words.Start();!Words.End();Words.Next())
		{
			w=NbDocsWords.GetInsertPtr<unsigned int>(Words()->GetId());
			if(Words()->InfoType()==infoWordList) w->SetInfoType(infoWordList);
			w->AddWeight(1.0);
		}
	}

	// Go through all documents, add the frequences of the words of "OK"
	// documents and substract the frequences of the words of "KO" documents.
	Docs=subprofile->GetProfDocCursor();
	for(Docs.Start();!Docs.End();Docs.Next())
	{
		CurDoc=dynamic_cast<GDocVector*>(Docs()->GetDoc());

		// Find list in function of the feedback
		Fdbk=Docs()->GetFdbk();
		if((IrrelFactor==0.0)&&(!(Fdbk & djOK))&&( !(Fdbk & djNav))&&(!(Fdbk & djKO))) continue;
		switch(Fdbk & djMaskJudg )
		{
			case djOK:
			case djNav:
				Add=true;
				Factor=RelFactor;
				break;

			case djKO:
				Add=Positive;
				Factor=FuzzyFactor;
				break;

			default:
				Add=false;
				Factor=IrrelFactor;
				break;
		}

		// Add total number of words and the occurences of each word of the current document.
		Words=CurDoc->GetWordWeightCursor();
		MaxFreq=CurDoc->GetMaxWeight();
		for(Words.Start();!Words.End();Words.Next())
		{
			w=Vectors.GetInsertPtr<unsigned int>(Words()->GetId());
			if(Words()->InfoType()==infoWordList) w->SetInfoType(infoWordList);
			Freq=Words()->GetWeight()/MaxFreq;
			if((isf)&&(NbDocs>1))
				Freq*=log(NbDocs/NbDocsWords.GetPtr<unsigned int>(Words()->GetId())->GetWeight());
			if(Add)
				w->AddWeight(Factor*Freq);
			else
				w->SubstractWeight(Factor*Freq);
		}
	}
}


//-----------------------------------------------------------------------------
void GProfileCalcFeedback::ComputeSubProfile(GSubProfileVector* s) throw(bad_alloc)
{
	GIWordWeight** ptr;
	unsigned int i,nb;
	GIWordsWeights* Vector=s->GetVector();

	// Clear the Vector.
	s->RemoveRefs();
	Vector->Clear();

	// Choose the elements to stay.
	if(Vectors.IsEmpty())
	{
		s->UpdateFinished();
		return;
	}

	// Put in Order an ordered version of Global
	if(Vectors.NbPtr+1>MaxOrderSize)
	{
		if(Order) delete[] Order;
		MaxOrderSize=static_cast<unsigned int>((Vectors.NbPtr+1)*1.1);
		Order=new GIWordWeight*[MaxOrderSize];
	}
	memcpy(Order,Vectors.Tab,Vectors.NbPtr*sizeof(GIWordWeight*));
	qsort(static_cast<void*>(Order),Vectors.NbPtr,sizeof(GIWordWeight*),GIWordsWeights::sortOrder);
	Order[Vectors.NbPtr]=0;

	//If MaxNonZero is null -> take all the words.
	if(MaxNonZero)
		nb=MaxNonZero;
	else
		nb=Vectors.NbPtr;
	for(i=nb+1,ptr=Order;(--i)&&(*ptr);ptr++)
		Vector->InsertPtr(new GIWordWeight(*ptr));

	// Update the references of the vector.
	s->UpdateRefs();

	//Tell the subprofile that the udpate is finished.
	s->UpdateFinished();
}


//-----------------------------------------------------------------------------
void GProfileCalcFeedback::Compute(GSubProfile* subprofile)
{
	// Compute the global vectors.
	ComputeGlobal(subprofile);

	// Compute the vector for each subprofile
	ComputeSubProfile((GSubProfileVector*)subprofile);
}


//------------------------------------------------------------------------------
void GProfileCalcFeedback::CreateParams(GParams* params)
{
	params->InsertPtr(new GParamUInt("MaxSize",60));
	params->InsertPtr(new GParamDouble("RelFactor",1.0));
	params->InsertPtr(new GParamDouble("FuzzyFactor",0.25));
	params->InsertPtr(new GParamDouble("IrrelFactor",0.75));
	params->InsertPtr(new GParamBool("Positive",false));
	params->InsertPtr(new GParamBool("isf",true));
}


//-----------------------------------------------------------------------------
GProfileCalcFeedback::~GProfileCalcFeedback(void)
{
	if(Order) delete[] Order;
}


//------------------------------------------------------------------------------
CREATE_PROFILECALC_FACTORY("Optimist and Pessimist Feedback Method",GProfileCalcFeedback)
